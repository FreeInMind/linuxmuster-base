#!/bin/bash

### BEGIN INIT INFO
# Provides:          linuxmuster-base
# Required-Start:    $network $local_fs
# Required-Stop:     $network $local_fs
# Should-Start:      
# Should-Stop:       
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: internal firewall script
# Description:       starts and stops internal firewall
### END INIT INFO

# Thomas Schmitt <tschmitt@linuxmuster.de>
# 05.01.2013

# source default settings
[ -f /etc/default/linuxmuster-base ] && . /etc/default/linuxmuster-base

# check if we are allowed to start
[ "$START_LINUXMUSTER" = "yes" ] || exit 0

# source linuxmuster defaults
. /usr/share/linuxmuster/config/dist.conf || exit 1

# source helperfunctions
. $HELPERFUNCTIONS || exit 1

# create $BLOCKEDHOSTSINTRANET if necessary
[ -e "$BLOCKEDHOSTSINTRANET" ] || touch $BLOCKEDHOSTSINTRANET

# read mac addresses
macs="$(grep -v ^# $WIMPORTDATA | awk -F\; '{ print $4 }' | tr a-z A-Z)"

# file which saves the fw rules
IPTRULES="$CACHEDIR/iptables"

# check if we were called on boot
echo "$0" | grep -q ^/etc/rc && ONBOOT=yes


# save rules and flush iptables rules completely
flush_fw() {

 # do only if there are rules
 if iptables -L IN-$IFACE &> /dev/null; then
  # save rules first
  iptables-save > "$IPTRULES" ; RC="$?"
  # remove it all
  iptables -D INPUT -i $IFACE -j IN-$IFACE
  iptables -F IN-$IFACE
  iptables -X IN-$IFACE
  if [ "$RC" != "0" ]; then
   echo " ... failed to save rules!"
   echo
   rm -f "$IPTRULES"
   exit "$RC"
  fi
 else
  rm -f "$IPTRULES"
 fi

} # flush_fw


stop_firewall() {

  echo -n "Stopping internal firewall"
  flush_fw
  echo "."

} # stop_firewall


create_mac_rules() {
 
 local RULE
 
 # write allowed ports rules
 if [ -f "$ALLOWEDPORTS" ]; then
  while read proto portrange; do
   [ "${proto:0:1}" = "#" ] && continue
   [[ -z "$portrange" || -z "$proto" ]] && continue
   portrange=${portrange//,/ }
   for p in $portrange; do
    for m in $macs; do
     validmac $m || continue
      RULE="-A IN-$IFACE -p $proto -m mac --mac-source $m -m $proto --dport $p -j ACCEPT"
      if [ -n "$INSERT_NR" ]; then
       sed "${INSERT_NR}i\
$RULE" -i "$IPTRULES"
      else
       echo "$RULE" >> "$IPTRULES"
      fi
    done
   done
  done <$ALLOWEDPORTS
 fi

 # strip blocked mac addresses from list
 for m in `cat $BLOCKEDHOSTSINTRANET`; do
  macs=${macs/$m/}
 done

 # write blocked ports rules
 if [ -f "$BLOCKEDPORTS" ]; then
  while read proto portrange; do
   [ "${proto:0:1}" = "#" ] && continue
   [[ -z "$portrange" || -z "$proto" ]] && continue
   portrange=${portrange//,/ }
   for p in $portrange; do
    for m in $macs; do
     validmac $m || continue
      RULE="-A IN-$IFACE -p $proto -m mac --mac-source $m -m $proto --dport $p -j ACCEPT"
      if [ -n "$INSERT_NR" ]; then
       sed "${INSERT_NR}i\
$RULE" -i "$IPTRULES"
      else
       echo "$RULE" >> "$IPTRULES"
      fi
    done
   done
  done <$BLOCKEDPORTS
 fi

} # create_mac_rules

# create all rules from scratch and write them to file
create_rulesfile() {

 # write header
 cat > "$IPTRULES" <<EOF
# Generated by linuxmuster-base on `date`
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:IN-$IFACE - [0:0]
-A INPUT -i $IFACE -j IN-$IFACE
-A IN-$IFACE -m state --state RELATED,ESTABLISHED -j ACCEPT
-A IN-$IFACE -s $ipcopip/32 -j ACCEPT
-A IN-$IFACE ! -s $internalnet/$internmask_short -j ACCEPT
EOF

 # write mandatory open ports rules
 if [ -f "$BASEPORTS" ]; then
  while read proto portrange; do
   [ "${proto:0:1}" = "#" ] && continue
   [[ -z "$portrange" || -z "$proto" ]] && continue
   portrange=${portrange//,/ }
   for p in $portrange; do
    echo "-A IN-$IFACE -p tcp -m tcp --dport $p -j ACCEPT" >> "$IPTRULES"
   done
  done <$BASEPORTS
 fi

 create_mac_rules

 # footer
 cat >> "$IPTRULES" <<EOF
-A IN-$IFACE -p icmp -m icmp --icmp-type 8 -j ACCEPT
-A IN-$IFACE -j REJECT --reject-with icmp-port-unreachable
COMMIT
# Completed on `date`
EOF

} # create_rulesfile


start_firewall() {

 echo -n "Starting internal firewall"
 
 if [ -n "$ONBOOT" -a -s "$IPTRULES" ]; then
  echo -n " on boot, loading saved file"
 else
  create_rulesfile
 fi
 
 if ! iptables-restore < "$IPTRULES"; then
  echo " ... failed to load $IPTRULES!"
  echo
  exit 1
 fi
 
 echo "."

} # start_firewall


# reload fw by modifying rules file
reload_firewall() {

 echo -n "Reloading internal firewall"

 # save rules
 iptables-save > "$IPTRULES" ; RC="$?"
 if [ "$RC" != "0" ]; then
  echo " ... failed to save rules!"
  echo
  rm -f "$IPTRULES"
  exit "$RC"
 fi

 # fetch all macs which have rules
 active_macs="$(grep -w mac "$IPTRULES" | awk '{ print $8 }' | sort -u)"

 # remove rules with macs not in workstations file
 local m
 for m in $active_macs; do
  stringinstring $m "$macs" && continue
  active_macs=${active_macs/$m/}
  grep -v "$m" "$IPTRULES" > "$IPTRULES.tmp"
  mv "$IPTRULES.tmp" "$IPTRULES"
 done
 strip_spaces "$active_macs"
 active_macs="$RET"

 # filter out macs which have already rules
 if [ -n "$active_macs" ]; then
  for m in $macs; do
   stringinstring $m "$active_macs" && macs=${macs/$m/}
  done
  strip_spaces "$macs"
  macs="$RET"
 fi

 # insert rules for new macs if there are any
 if [ -n "$macs" ]; then
  # compute line number to insert before
  INSERT_NR="$(grep -m1 -n -w icmp "$IPTRULES" | awk -F\: '{ print $1 }')"
  # exit if line number cannot be determined
  if [ -n "$INSERT_NR" ]; then
   create_mac_rules
  else
   echo " ... error in $IPTRULES!"
   echo
   [ -e "$IPTRULES" ] && mv "$IPTRULES" "$IPTRULES.failed"
   exit 1
  fi
 fi

 # load fw rules files
 if ! iptables-restore < "$IPTRULES"; then
  echo " ... failed to load $IPTRULES!"
  echo
  exit 1
 fi

 echo "."

} # reload_firewall


case "$1" in

 start)
  start_firewall
  ;;

 stop)
  stop_firewall
  ;;

 restart)
  stop_firewall
  start_firewall
  ;;

 reload|force-reload)
  reload_firewall
  ;;

 *)
  echo "Usage: $0 <start|stop|reload|restart|force-reload>"
  ;;

esac

exit 0
